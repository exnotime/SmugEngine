#include "ModelLoader.h"
#include "TextureLoader.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <algorithm>

ModelLoader::ModelLoader() {}
ModelLoader::~ModelLoader() {}

char* ModelLoader::LoadModel(const std::string& filename, ModelInfo& model) {
    Assimp::Importer importer;
    const aiScene* scene = importer.ReadFile(filename, aiProcess_CalcTangentSpace | aiProcess_FlipUVs
                           | aiProcess_GenUVCoords | aiProcess_JoinIdenticalVertices | aiProcess_Triangulate);
    if (scene) {
        //meshes
        if (scene->HasMeshes()) {
            model.MeshCount = scene->mNumMeshes;
            model.Meshes = new MeshInfo[model.MeshCount];
            uint32_t indexCount = 0;
            for (int m = 0; m < model.MeshCount; ++m) {
                MeshInfo& meshInfo = model.Meshes[m];
                aiMesh* mesh = scene->mMeshes[m];
                meshInfo.Material = mesh->mMaterialIndex;
                meshInfo.VertexCount = mesh->mNumVertices;
                meshInfo.Vertices = new Vertex[meshInfo.VertexCount];
                for (int v = 0; v < meshInfo.VertexCount; ++v) {
                    meshInfo.Vertices[v].Position = glm::vec3(mesh->mVertices[v].x, mesh->mVertices[v].y, mesh->mVertices[v].z);
                    meshInfo.Vertices[v].Normal = glm::normalize(glm::vec3(mesh->mNormals[v].x, mesh->mNormals[v].y, mesh->mNormals[v].z));
                    glm::vec3 t = glm::normalize(glm::vec3(mesh->mTangents[v].x, mesh->mTangents[v].y, mesh->mTangents[v].z));
                    glm::vec3 b = glm::normalize(glm::vec3(mesh->mBitangents[v].x, mesh->mBitangents[v].y, mesh->mBitangents[v].z));
                    if (glm::dot(glm::cross(meshInfo.Vertices[v].Normal, t), b) < 0.0f) {
                        t *= -1;
                    }
                    meshInfo.Vertices[v].Tangent = t;
                    meshInfo.Vertices[v].TexCoord = glm::vec2(mesh->mTextureCoords[0][v].x, mesh->mTextureCoords[0][v].y);
                }
                meshInfo.IndexCount = mesh->mNumFaces * 3;
                meshInfo.Indices = new uint32_t[meshInfo.IndexCount];
                for (int f = 0; f < mesh->mNumFaces; ++f) {
                    meshInfo.Indices[f * 3] = indexCount + mesh->mFaces[f].mIndices[0];
                    meshInfo.Indices[f * 3 + 1] = indexCount + mesh->mFaces[f].mIndices[1];
                    meshInfo.Indices[f * 3 + 2] = indexCount + mesh->mFaces[f].mIndices[2];
                }
                indexCount += meshInfo.VertexCount;
            }
        }
        if (scene->HasMaterials()) {
            model.MaterialCount = scene->mNumMaterials;
            model.Materials = new MaterialInfo[model.MaterialCount];
            for (int m = 0; m < model.MaterialCount; ++m) {
                aiMaterial* mat = scene->mMaterials[m];
                std::string dir = filename.substr(0, filename.find_last_of('/') + 1);
                aiString path;
                TextureLoader texLoader;
                if (mat->GetTextureCount(aiTextureType_DIFFUSE) > 0) {
                    mat->GetTexture(aiTextureType_DIFFUSE, 0, &path);
                    texLoader.LoadTexture(dir + path.data, model.Materials[m].Albedo);
                }
                //obj stores normals in height
                if (mat->GetTextureCount(aiTextureType_HEIGHT)) {
                    mat->GetTexture(aiTextureType_HEIGHT, 0, &path);
                    texLoader.LoadTexture(dir + path.data, model.Materials[m].Normal);
                }
                //dae in normals
                if (mat->GetTextureCount(aiTextureType_NORMALS)) {
                    mat->GetTexture(aiTextureType_NORMALS, 0, &path);
                    texLoader.LoadTexture(dir + path.data, model.Materials[m].Normal);
                }
                if (mat->GetTextureCount(aiTextureType_SPECULAR)) {
                    mat->GetTexture(aiTextureType_SPECULAR, 0, &path);
                    texLoader.LoadTexture(dir + path.data, model.Materials[m].Roughness);
                }
                if (mat->GetTextureCount(aiTextureType_EMISSIVE)) {
                    mat->GetTexture(aiTextureType_EMISSIVE, 0, &path);
                    texLoader.LoadTexture(dir + path.data, model.Materials[m].Metal);
                }
            }
        } else {
            //force default material
            model.MaterialCount = 1;
            model.Materials = new MaterialInfo();
            for (int m = 0; m < model.MeshCount; ++m) {
                model.Meshes[m].Material = 0;
            }
        }
    } else {
        return "Assimp error";
    }
    return nullptr;
}