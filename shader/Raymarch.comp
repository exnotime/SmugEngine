#version 430 core

#define WORK_GROUP_SIZE 32
layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(rgba8, binding = 0) writeonly restrict uniform image2D output_img;
layout(binding = 1) uniform sampler2D g_DepthTex;

layout(binding = 2) uniform PerFrame{
    mat4 invViewProj;
    vec4 CamPos;
};

#include "DistOps.glsl"
#include "lighting.glsl"

float near = 0.1;
float far = 250.0;
int MaxIt = 64;

vec2 map(vec3 p){
    float plane = udPlane(p, normalize(vec4(0,-1,0,-10)));
    vec3 repP = opTwist(p,0.75f);
    float box = udRoundBox(repP, vec3(2,1,2), 0.1, vec3(0, 0, 0));
    float sphere = sdSphere(p, 2.4f, vec3(0,-2,0));
    return vec2(opBlend(sphere, box), 1);
}

vec3 CastRay(vec3 ro, vec3 rd){
    float t = near;
    float m = -1.0f;
    int i = 0;
    for(; i < MaxIt; i++){
        float precis = 0.0005*t;
        vec2 res = map(ro + rd * t);
        if(res.x < precis || t > far) break;
        t += res.x;
        m = res.y;
    }
    if(t > far) m = -1.0f;
    return vec3(t,m,i);
}

vec3 CalcNormal( vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                  e.yyx*map( pos + e.yyx ).x +
                  e.yxy*map( pos + e.yxy ).x +
                  e.xxx*map( pos + e.xxx ).x );
}

vec3 getFloorTexture(vec3 p) {
	vec2 m = mod(p.xz, 100.0f) - vec2(50.0f);
	return m.x * m.y > 0.0f ? vec3(0.1f) : vec3(1.0f);
}

float RaytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {
	return dot(o - ro, n) / dot(rd, n);
}

void main() {
    ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = screenPos / vec2(1600, 900);
    vec2 hcs = ((vec2(screenPos) + vec2(0.5)) * 2) / vec2(1600, 900) - vec2(1);
    const float aspect = 16.0f / 9.0f;
    vec4 posH =  (invViewProj * vec4(hcs.x, hcs.y, 0.0, 1.0));
    vec3 ro = posH.xyz / posH.w;
    vec3 rd = normalize(ro - CamPos.xyz);
    vec3 res = CastRay(ro, rd);
    //calc posw and normal
    vec3 posw = (ro + rd * res.x );
    vec3 normal = CalcNormal(posw);
    vec3 color = vec3(0.5, 0.7, 0.5);
    //raytrace plane so we dont get ugly artifacts
    float d = texture(g_DepthTex, vec2(screenPos)).r;
    d = near / (far - d * (far - near)); //linearize the depth buffer
    if( d >= (res.x - near) / (far - near)){
        const vec3 lightDir = normalize(vec3(0.2f, -1.0f, -0.4f));
        const vec3 toCam = normalize(CamPos.xyz - posw);
        vec3 litColor = CalcDirLight(lightDir, color, normal, toCam, 0.9f, 0.0f);
        litColor += CalcIBLLight( normal, toCam, color, 0.9f, 0.0f);
        imageStore(output_img, screenPos, vec4(litColor,1));
    }
}
