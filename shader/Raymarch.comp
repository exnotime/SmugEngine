#version 430 core

#define WORK_GROUP_SIZE 32
layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(rgba8, binding = 0) writeonly restrict uniform image2D output_img;
layout(binding = 1) uniform sampler2D g_DepthTex;

layout(binding = 2) uniform PerFrame{
    mat4 invViewProj;
    vec4 CamPos;
    vec4 Lightdir;
    uint SphereCount;
};

struct Sphere{
    vec3 P;
    float R;
    vec4 C;
};
#define MAX_SPHERES 100
layout(binding = 3) buffer Primitives{
    Sphere g_Spheres[MAX_SPHERES];
};

#include "lighting.glsl"
#include "hg_sdf.glsl"

float near = 0.1;
float far = 250.0;
int MaxIt = 128;

float map(vec3 p){
    float d = far;
    for(uint s = 0; s < SphereCount; ++s){
        Sphere sp = g_Spheres[s];
        d = min(d, fSphere(p - sp.P, sp.R));
    }
    return d;
}

float CastRay(vec3 ro, vec3 rd){
    float t = near;
    for(int i = 0; i < MaxIt; i++){
        float precis = 0.0005*t;
        float res = map(ro + rd * t);
        if(res < precis || t > far) break;
        t += res.x;
    }
    return t;
}

vec3 CalcNormal( vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                  e.yyx*map( pos + e.yyx ).x +
                  e.yxy*map( pos + e.yxy ).x +
                  e.xxx*map( pos + e.xxx ).x );
}

vec3 getFloorTexture(vec3 p) {
	vec2 m = mod(p.xz, 100.0f) - vec2(50.0f);
	return m.x * m.y > 0.0f ? vec3(0.1f) : vec3(1.0f);
}

float RaytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {
	return dot(o - ro, n) / dot(rd, n);
}

void main() {
    ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);
    if(screenPos.x > 1920 || screenPos.y > 1080)
        return;
    vec2 uv = screenPos / vec2(1920, 1080);
    vec2 hcs = ((vec2(screenPos) + vec2(0.5)) * 2) / vec2(1920, 1080) - vec2(1);

    vec4 posH =  (invViewProj * vec4(hcs.x, hcs.y, 0.0, 1.0));
    vec3 ro = posH.xyz / posH.w;
    vec3 rd = normalize(ro - CamPos.xyz);
    float t = CastRay(ro, rd);
    //calc posw and normal
    vec3 posw = (ro + rd * t );
    vec3 normal = CalcNormal(posw);

    vec3 colors[] = {vec3(0.3, 0.4, 0.3), vec3(1.0, 0.71,0.29), vec3(1.0, 0.0, 0.0) };
    vec3 color = colors[0];

    float d = texture(g_DepthTex, vec2(screenPos)).r;
    d = near / (far - d * (far - near)); //linearize the depth buffer
    if( d >= (t - near) / (far - near)){
        const vec3 toCam = normalize(CamPos.xyz - posw);
        float r = 0.6;
        float m = 0.0;

        vec3 litColor = CalcDirLight(-normalize(Lightdir.xyz), color, normal, toCam, r, m);
        litColor += CalcIBLLight( normal, toCam, color, r, m);

        //litColor = ditherRGB(litColor, vec2(screenPos));
        //litColor = litColor / (litColor + vec3(1.0));

        imageStore(output_img, screenPos, vec4(litColor,1));
    }
}
