#version 430 core

#define WORK_GROUP_SIZE 32
layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(rgba8, binding = 0) writeonly restrict uniform image2D output_img;
layout(binding = 1) uniform sampler2D g_DepthTex;

layout(binding = 2) uniform PerFrame{
    mat4 invViewProj;
    vec4 CamPos;
};

#include "DistOps.glsl"
#include "lighting.glsl"

float near = 0.1;
float far = 250.0;
int MaxIt = 256;

vec2 map(vec3 p){
    //float plane = udPlane(p, normalize(vec4(0,-1,0,-10)));
    //vec3 repP = opTwist(p,0.75f);
    float box = udRoundBox(p, vec3(2,0.5,2), 0.2, vec3(0, 0.0, 0));
    float sphere = sdSphere(p, 100.0, vec3(0,-100,0));
    float sun = sdSphere(p, 10.0, vec3(0, 20, 0));
    vec2 blend = opBlend(vec2(sphere, 0), vec2(box,1));
    blend = opUnion(blend, vec2(sun, 2));
    return blend;
}

vec3 CastRay(vec3 ro, vec3 rd){
    float t = near;
    float m = -1.0f;
    int i = 0;
    for(; i < MaxIt; i++){
        float precis = 0.0005*t;
        vec2 res = map(ro + rd * t);
        if(res.x < precis || t > far) break;
        t += res.x;
        m = res.y;
    }
    if(t > far) m = -1.0f;
    return vec3(t,m,i);
}

vec3 CalcNormal( vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                  e.yyx*map( pos + e.yyx ).x +
                  e.yxy*map( pos + e.yxy ).x +
                  e.xxx*map( pos + e.xxx ).x );
}

vec3 getFloorTexture(vec3 p) {
	vec2 m = mod(p.xz, 100.0f) - vec2(50.0f);
	return m.x * m.y > 0.0f ? vec3(0.1f) : vec3(1.0f);
}

float RaytraceFloor(vec3 ro, vec3 rd, vec3 n, vec3 o) {
	return dot(o - ro, n) / dot(rd, n);
}

void main() {
    ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = screenPos / vec2(1920, 1080);
    vec2 hcs = ((vec2(screenPos) + vec2(0.5)) * 2) / vec2(1920, 1080) - vec2(1);
    const float aspect = 16.0f / 9.0f;
    vec4 posH =  (invViewProj * vec4(hcs.x, hcs.y, 0.0, 1.0));
    vec3 ro = posH.xyz / posH.w;
    vec3 rd = normalize(ro - CamPos.xyz);
    vec3 res = CastRay(ro, rd);
    //calc posw and normal
    vec3 posw = (ro + rd * res.x );
    vec3 normal = CalcNormal(posw);

    vec3 colors[] = {vec3(0.3, 0.5, 0.3), vec3(1.0, 0.71,0.29), vec3(1.0) };
    int c1 = int(floor(res.y));
    int c2 = (c1 + 1) % 3;
    vec3 color = mix(colors[c1], colors[c2], fract(res.y));

    //raytrace plane so we dont get ugly artifacts
    float d = texture(g_DepthTex, vec2(screenPos)).r;
    d = near / (far - d * (far - near)); //linearize the depth buffer
    if( d >= (res.x - near) / (far - near)){
        const vec3 lightDir = normalize(vec3(0.2f, 1.0f, -0.4f));
        const vec3 toCam = normalize(CamPos.xyz - posw);
        float r = 1.0;
        float m = 0.0;

        vec3 litColor = CalcDirLight(lightDir, color, normal, toCam, r, m);
        litColor += CalcIBLLight( normal, toCam, color, r, m);

        litColor = ditherRGB(litColor, vec2(screenPos));
        //litColor = litColor / (litColor + vec3(1.0));
        //litColor = pow(litColor, vec3(1.0/2.2));

        imageStore(output_img, screenPos, vec4(litColor,1));
    }
}
