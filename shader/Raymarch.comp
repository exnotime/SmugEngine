#version 430 core

#define WORK_GROUP_SIZE 32
layout(local_size_x = WORK_GROUP_SIZE, local_size_y = WORK_GROUP_SIZE) in;

layout(rgba8, binding = 0) writeonly restrict uniform image2D output_img;
layout(binding = 1) uniform sampler2D g_DepthTex;

layout(binding = 2) uniform PerFrame{
    mat4 invViewProj;
    vec4 CamPos;
};

#include "DistOps.glsl"
#include "lighting.glsl"

float near = 0.1;
float far = 100.0;
int MaxIt = 1024;

vec2 map(vec3 p){
    float plane = udPlane(p, normalize(vec4(0,-1,0,-10)));
    vec3 repP = opTwist(p); //opRepeat(, vec3(10, 0, 10));
    float box = udRoundBox(repP, vec3(1), 0.5, vec3(0, 0, 0));
    float sphere = sdSphere(p, 2.4f, vec3(0,-2,0));
    return vec2(opUnion(opBlend(sphere, box), plane), 1);
}

vec3 CastRay(vec3 ro, vec3 rd){
    float t = near;
    float m = -1.0f;
    int i = 0;
    for(; i < MaxIt; i++){
        float precis = 0.0005*t;
        vec2 res = map(ro + rd * t);
        if(res.x < precis || t > far) break;
        t += res.x;
        m = res.y;
    }
    if(t > far) m = -1.0f;
    return vec3(t,m,i);
}

vec3 CalcNormal( vec3 pos ){
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ).x +
                  e.yyx*map( pos + e.yyx ).x +
                  e.yxy*map( pos + e.yxy ).x +
                  e.xxx*map( pos + e.xxx ).x );
}

void main() {
    ivec2 screenPos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = screenPos / vec2(1600, 900);
    vec2 hcs = (screenPos * 2) / vec2(1600, 900) - vec2(1);
    const float aspect = 16.0f / 9.0f;
    vec4 posH =  (invViewProj * vec4(hcs.x, hcs.y, 0.0, 1.0));
    vec3 ro = posH.xyz / posH.w;
    vec3 rd = normalize(ro - CamPos.xyz);
    vec3 res = CastRay(ro, rd);
    float d = texture(g_DepthTex, vec2(screenPos)).r;
    d = near / (far - d * (far - near));
    if( d >= (res.x - near) / (far - near) && res.y > -0.5f){

        vec3 posw = (ro + rd * res.x );
        vec3 normal = CalcNormal(posw);
        vec3 lightDir = normalize(vec3(0.2f, -1.0f, -0.4f));
        float diff = LambertDiffuse(normal, lightDir);
        float spec = 0;
        if(diff > 0){
            spec = BlinnSpecular(normal, lightDir, normalize(CamPos.xyz - posw), 16.0);
        }
        vec3 color = (diff + spec + 0.01) * vec3(0.5,0.4, 0.5);
        imageStore(output_img, screenPos, vec4(color,1));

    }
}
